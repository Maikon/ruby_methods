`::[]` *creates new array with given objects -> `Array.[](1,2,'name') --> [1,2,'name']`*

`::new` *comes in three variations. The first one is `Array.new(size = 0, obj = nil)` where it creates a new array with the specified size, populated with the same object passed as a second argument i.e `Array.new(3,'Hi!') --> ['Hi!','Hi!','Hi!']`. __Note:__ The second parameter, the object in this case, will be used as the value for all the array elements. A change to one of them, affects all of them: `c = Array.new(2, Hash.new) --> [{},{}] --> c[0]['nino'] = 'hola' --> [{'nino' => 'hola'},{'nino' => 'hola'}]`* 
*If none of those two are provided, it will return an empty array.*
*The second variation is calling Array.new with a single argument, an already existing array, which will then create a copy of `Array.new(targ_array)`. The array is generated by calling `to_ary` on the parameter.*
*The third variation comes in a similar form, this time passing a block to the newly created array and using the index of each time `Array.new(3) {|x| x * 5 } --> [0, 5, 10]`.*

*Another way of creating a new array using a hash to populate it: `Array({name: 'Joe', last_name: 'Doe'}) --> [[:name, 'Joe'],[:last_name, 'Doe']]`*

*Fast way to create multi-dimensional arrays:* 
`Array.new(Array.new(2) { Array.new(2) { Array.new(2)}}) --> [[[nil],[nil]],[[nil],[nil]]]` !! (o_o) !!

`::try_convert` *this method tries to convert an object into an array using `to_ary` method. It returns the converted array or `nil` if the object cannot be converted for any reason i.e `Array.try_convert(['blah']) --> ['blah'], Array.try_convert(1) --> nil`. This is useful when checking if an argument is an array or not. __Note:__ the same method can be found for the `String` class.*

`#&` *__'set intersection'__. It returns a new array containing elements that are common in both arrays leaving out any duplicates i.e `[1,1,2,3,4,5,5] & [2,1,5] --> [1,2,5]` __Note:__ the order is preserved from the original array. It compares elements using their hash and eql? methods. Similar to the `uniq` method.*

`#*` *__'repetition'__. Comes in two flavors. If it's passed with an int argument i.e `[2,1,5] * 2` it returns a new array with built by adding the int copies `[2,1,5,2,1,5]`. If instead of int is passed with a string i.e `[2,1,5] * '.'` it returns a new string `'2.1.5'` similar to using the `ary.join(str)` method*

`#+` *__'concatenation'__. Returns a new array built by adding two arrays together to produce a third array i.e `[1,2,3] + [4,5,6] --> [1,2,3,4,5,6]` similar to the #concat method*

`#-` *__'difference'__. Returns a new array which is a copy of the first array minus the elements that are common in both arrays excluding doubles i.e `[1,1,2,3,4,4,5,6,6] - [4,5,6] --> [1,1,2,3]`. Compares elements using their hash and eql? method.*

`#<<` *__'append'__. It pushes the object that's passed to it, to the end of the array i.e:* 
`[1,2,3] << [4,5] << 'wow' --> [1,2,3,4,5,'wow']` *worth noting that this CHANGES the original array, it does not create a copy of it.*

`#<=>` *__'comparison'__. This returns an integer, -1, 0, 1 if the array_1 is less than, equal to or greater than array_2 i.e --> `array_1 = [1,2,3], array_2 = [1,2,4] --> array_1 <=> array_2 --> -1 `. If the two values cannot be compared, it returns nil. The comparison works through the elements of the arrays, the first two that are not equal, will determine the value for the whole comparison. If the values are equal it will try and compare them using each array's length.*

`#==` *__'equality'__. Returns True or False when checking if two arrays contain the same number of elements and if those elements equal each other from each array i.e:* 
`array_1 = [1,2,'a'], array_2 = [1,2,'a'] --> array_1 == array_2 --> True`

`#[]` *__'element reference'__. Various options, returns a new array or specific object depending on the parameters:* 
*`array = [1,2,3,4,5,6]` 1)`array[1] --> 2`, 2) `array[1,3] --> [2,3,4]`, 3) `array[3..5] --> [4,5,6]`*
*4) `array.slice(3) --> 4`, 5) `array.slice(2,4) --> [3,4,5,6]` 6) `array.slice(2..4) --> [3,4,5]`*

#####*Rest to follow...*


`#[]=` *__'element assignment'__. Again, various ways to do this. First up: `a = Array.new` then if you do `a[3] = 4` it will place the number 4 at index 3. If the array was previously empty, it will fill the rest of indexes with nil so the result of the previous example will be `[nil,nil,nil,4]`*

`#assoc`
`#at`
`#bsearch`
`#clear`
`#collect`
`#collect!`
`#combination`
`#compact`
`#compact!`
`#concat`
`#count`
`#cycle`
`#delete`
`#delete_at`
`#delete_if`
`#drop`
`#drop_while`
`#each`
`#each_index`
`#empty?`
`#eql?`
`#fetch`
`#fill`
`#find_index`
`#first`
`#flatten`
`#flatten!`
`#frozen?`
`#hash`
`#include?`
`#index`
`#initialize_copy`
`#insert`
`#inspect`
`#join`
`#keep_if`
`#last`
`#length`
`#map`
`#map!`
`#pack`
`#permutation`
`#pop`
`#product`
`#push`
`#rassoc`
`#reject`
`#reject!`
`#repeated_combination`
`#repeated_permutation`
`#replace`
`#reverse`
`#reverse!`
`#reverse_each`
`#rindex`
`#rotate`
`#rotate!`
`#sample`
`#select`
`#select!`
`#shift`
`#shuffle`
`#shuffle!`
`#size`
`#slice`
`#slice!`
`#sort`
`#sort!`
`#sort_by!`
`#take`
`#take_while`
`#to_a`
`#to_ary`
`#to_h`
`#to_s`
`#transpose`
`#uniq`
`#uniq!`
`#unshift`
`#values_at`
`#zip`
`#|`